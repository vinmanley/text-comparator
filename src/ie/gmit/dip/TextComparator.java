package ie.gmit.dip;

import java.util.HashSet;
import java.util.Map;

/**
 * The class <b>TextComparator</b> compares the Map objects generated by subject
 * and query texts and returns the cosine similarity of strings in those Map
 * objects.
 * 
 * @author Vincent Manley
 *
 */
public class TextComparator {
	public Map<String, Integer> subjectMap;
	public Map<String, Integer> queryMap;

	/**
	 * Constructor for <b>TextComparator</b> class. Parameters are two Map objects
	 * generated from subject and query texts.
	 * 
	 * @param subjectMap
	 * @param queryMap
	 */
	public TextComparator(Map<String, Integer> subjectMap, Map<String, Integer> queryMap) {
		this.subjectMap = subjectMap;
		this.queryMap = queryMap;
	}

	// Adapted from:
	// https://blog.nishtahir.com/fuzzy-string-matching-using-cosine-similarity/

	/**
	 * Compares Map objects for similarity of String elements.
	 * 
	 * 
	 * @return cosine similarity of subjectMap and queryMap
	 */
	public double cosineSimilarity() {
		HashSet<String> intersection = new HashSet<>(subjectMap.keySet());

		intersection.retainAll(queryMap.keySet());

		double dotProduct = 0, magnitudeA = 0, magnitudeB = 0;

		for (String item : intersection) {
			System.out.println(subjectMap.get(item));
			dotProduct += subjectMap.get(item) * queryMap.get(item);
			System.out.println(dotProduct);
		}

		for (String k : subjectMap.keySet()) {
			magnitudeA += Math.pow(subjectMap.get(k), 2);
		}

		for (String k : queryMap.keySet()) {
			magnitudeB += Math.pow(queryMap.get(k), 2);
		}

		return dotProduct / Math.sqrt(magnitudeA * magnitudeB);
	}
}
